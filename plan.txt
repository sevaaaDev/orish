argv[1]: 0x000001 [h|e|l|l|o|0|w|o|r|l|d]
tokens[0]: 0x000001
tokens[1]: 0x000006
tokens[2]: \0



        tokens[] parser(char* line)
           |
           v
execvp(tokens[0], tokens)


argv[1]: 0x000001 [echo hello; echo hi]
        tree(semicolon)
         /         \
tree(command) tree(command)


argv[1]: 0x000001 [echo hello\0 echo hi]
tokens[0]: echo hello
tokens[1]: echo hi

                ;
               / \
              ;   3
             / \
            1   2  

if (!left)
    left = strtok
right = strtok
tree semi;
semi.left = left
semi.right = right
left = semi

          ;
       /      \
echo hell      ;
            /     \   
        echo hi    ;
                /       \
            echo hai    NULL
make_tree() {
    for i = 0; i < len(t); i+=2 {
        left = t[i]
        right = t[i+1]
        tree semi = {.left = left, .right = right}
    }
    return semi
}

lexer() {
    tokens[]
    argv[]
    arg = line
    i = 0
    while (line[i] != \0) {
        c = line[i] 
        if c == ' ' {
            *c = \0
            push arg to argv
            arg = line[i+1]
        }
        if c == ; {
                
        }
        ++i
        
        
    }
}

[cmd|;|cmd|;|cmd]
e ::= command;e | command

e() {
    l = pop
    if next == ;
        pop
        r = e()
        tree.left = l
        tree.right = r
        l = tree
    return l
}

    ;;echo hello ;; cat main
while (!is_eol()) {
    c = advance()
    switch c {
        case ' ':
            break
        case ';':
            addToken(SEMI)
            break
        default: 
            do {
                while(is(' ')) advance()
                ptr = c
                while(!is(' ') and !is_eol() and !next_is(';')) advance()
                push_word(ptr)
            } while (!is_eol() and !next_is(';'))
            addToken(COMMAND)
    }
}
